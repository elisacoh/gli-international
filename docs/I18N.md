# Internationalization (i18n) Guide

## Overview

GLI International supports multiple languages with a first-class internationalization (i18n) architecture. The platform currently supports:

- **French (fr)** - Default language
- **English (en)**
- **Georgian (ka)**

Additional languages can be easily added in the future.

## Architecture

### Frontend i18n (next-intl)

The frontend uses `next-intl` for internationalization, which provides:
- URL-based locale routing
- Server-side and client-side translations
- Type-safe translations
- Automatic locale detection

### Backend i18n

The backend stores multilingual content in JSONB format in PostgreSQL, allowing flexible querying by language.

### Database i18n

Multilingual content is stored as JSON with language keys:

```json
{
  "fr": "Formation en implantologie",
  "en": "Implantology Training",
  "ka": "იმპლანტოლოგიის ტრენინგი"
}
```

## Frontend Implementation

### Configuration

**i18n Configuration** (`frontend/src/i18n.ts`):

```typescript
import { getRequestConfig } from 'next-intl/server';

export const locales = ['fr', 'en', 'ka'] as const;
export type Locale = (typeof locales)[number];
export const defaultLocale: Locale = 'fr';

export default getRequestConfig(async ({ locale }) => {
  return {
    messages: (await import(`../messages/${locale}/common.json`)).default,
  };
});
```

**Middleware** (`frontend/src/middleware.ts`):

```typescript
import createMiddleware from 'next-intl/middleware';
import { locales, defaultLocale } from './i18n';

export default createMiddleware({
  locales,
  defaultLocale,
  localePrefix: 'always',
});

export const config = {
  matcher: ['/', '/(fr|en|ka)/:path*'],
};
```

### Translation Files

**Structure:**
```
frontend/messages/
├── fr/
│   ├── common.json
│   ├── auth.json
│   └── formations.json
├── en/
│   ├── common.json
│   ├── auth.json
│   └── formations.json
└── ka/
    ├── common.json
    ├── auth.json
    └── formations.json
```

**Example** (`messages/fr/common.json`):

```json
{
  "home": {
    "title": "Plateforme de Formation Médicale",
    "description": "Formations professionnelles pour dentistes et médecins"
  },
  "nav": {
    "home": "Accueil",
    "formations": "Formations",
    "about": "À propos"
  }
}
```

### Usage in Components

**Server Component:**

```typescript
import { useTranslations } from 'next-intl';

export default function HomePage() {
  const t = useTranslations('home');

  return (
    <div>
      <h1>{t('title')}</h1>
      <p>{t('description')}</p>
    </div>
  );
}
```

**Client Component:**

```typescript
'use client';

import { useTranslations } from 'next-intl';

export default function LoginForm() {
  const t = useTranslations('auth.login');

  return (
    <form>
      <label>{t('email')}</label>
      <input type="email" placeholder={t('email')} />
      <button>{t('submit')}</button>
    </form>
  );
}
```

### URL Structure

The locale is always included in the URL:

- `/fr/` - French homepage
- `/en/formations` - English formations page
- `/ka/admin/users` - Georgian admin users page

**Generating Localized Links:**

```typescript
import { Link } from 'next-intl';

<Link href="/formations">
  {t('nav.formations')}
</Link>
// Automatically uses current locale
// Renders: /fr/formations (if locale is fr)
```

**Switching Languages:**

```typescript
'use client';

import { useRouter, usePathname } from 'next/navigation';
import { useLocale } from 'next-intl';

export function LanguageSwitcher() {
  const router = useRouter();
  const pathname = usePathname();
  const currentLocale = useLocale();

  const switchLocale = (newLocale: string) => {
    // Remove current locale from pathname
    const newPath = pathname.replace(`/${currentLocale}`, `/${newLocale}`);
    router.push(newPath);
  };

  return (
    <select value={currentLocale} onChange={(e) => switchLocale(e.target.value)}>
      <option value="fr">Français</option>
      <option value="en">English</option>
      <option value="ka">ქართული</option>
    </select>
  );
}
```

## Backend Implementation

### Querying Multilingual Content

**Get formation in specific language:**

```python
from sqlalchemy import func

def get_formation_in_locale(formation_id: str, locale: str = 'fr'):
    formation = db.query(Formation).filter(Formation.id == formation_id).first()

    return {
        'id': formation.id,
        'title': formation.title.get(locale, formation.title.get('fr')),
        'description': formation.description.get(locale, formation.description.get('fr')),
        'price': formation.price,
        # ... other fields
    }
```

**Search formations by title (multilingual):**

```python
# Search in all languages
search_term = "implant"
formations = db.query(Formation).filter(
    func.jsonb_path_exists(
        Formation.title,
        f'$.* ? (@ like_regex "{search_term}" flag "i")'
    )
).all()
```

### API Response Format

**Single Language Response:**

```json
{
  "id": "123",
  "title": "Formation en implantologie",
  "description": "Apprenez les techniques...",
  "locale": "fr"
}
```

**Multilingual Response (for admin/management):**

```json
{
  "id": "123",
  "title": {
    "fr": "Formation en implantologie",
    "en": "Implantology Training",
    "ka": "იმპლანტოლოგიის ტრენინგი"
  },
  "description": {
    "fr": "Apprenez les techniques...",
    "en": "Learn the techniques...",
    "ka": "ისწავლეთ ტექნიკა..."
  }
}
```

## Database Schema

### JSONB Columns

All user-facing text fields use JSONB:

```sql
CREATE TABLE formations (
    id UUID PRIMARY KEY,
    title JSONB NOT NULL,
    description JSONB NOT NULL,
    short_description JSONB NOT NULL,
    -- ...
);
```

### Indexing for Search

GIN indexes enable fast full-text search:

```sql
CREATE INDEX idx_formations_title_gin
ON formations USING GIN (title);

CREATE INDEX idx_formations_description_gin
ON formations USING GIN (description);
```

### Example Queries

**Get all formations with French title:**

```sql
SELECT
    id,
    title->>'fr' as title,
    description->>'fr' as description
FROM formations
WHERE is_published = true;
```

**Search in French:**

```sql
SELECT *
FROM formations
WHERE title->>'fr' ILIKE '%implant%'
   OR description->>'fr' ILIKE '%implant%';
```

## Adding a New Language

### 1. Frontend

**Update i18n config** (`frontend/src/i18n.ts`):

```typescript
export const locales = ['fr', 'en', 'ka', 'ru'] as const; // Add 'ru'
```

**Create translation files:**

```bash
mkdir frontend/messages/ru
cp frontend/messages/en/common.json frontend/messages/ru/common.json
# Translate the content
```

**Update middleware** (`frontend/src/middleware.ts`):

```typescript
export const config = {
  matcher: ['/', '/(fr|en|ka|ru)/:path*'], // Add 'ru'
};
```

### 2. Database

**Add translations to existing formations:**

```sql
UPDATE formations
SET title = jsonb_set(
    title,
    '{ru}',
    '"Название на русском"'
)
WHERE id = 'formation-id';
```

### 3. Admin Interface

Update admin forms to include new language fields.

## Translation Workflow

### For Developers

1. **Add new translation keys** in English first:
   ```json
   {
     "newFeature": {
       "title": "New Feature",
       "description": "This is a new feature"
     }
   }
   ```

2. **Use the key in code:**
   ```typescript
   const t = useTranslations('newFeature');
   <h1>{t('title')}</h1>
   ```

3. **Mark for translation:**
   - Add `// TODO: Translate` comment
   - Or create a translation ticket

### For Translators

**Tools:**
- Use a JSON editor or online tool
- Maintain consistent terminology
- Keep formatting (HTML, placeholders) intact

**Guidelines:**
- Match the tone and style of existing translations
- Consider cultural context
- Test translations in the UI

**Translation Memory:**

Create `docs/glossary.md` for consistent terminology:

| English | French | Georgian |
|---------|--------|----------|
| Formation | Formation | ტრენინგი |
| Enrollment | Inscription | ჩარიცხვა |
| Payment | Paiement | გადახდა |

## Right-to-Left (RTL) Support

For future Arabic or Hebrew support:

**Add RTL detection:**

```typescript
// frontend/src/lib/utils.ts
export const isRTL = (locale: string) => {
  return ['ar', 'he', 'fa'].includes(locale);
};
```

**Update layout:**

```typescript
<html lang={locale} dir={isRTL(locale) ? 'rtl' : 'ltr'}>
```

**Tailwind RTL plugin:**

```bash
npm install tailwindcss-rtl
```

## Date and Number Formatting

**Dates:**

```typescript
import { useLocale } from 'next-intl';

const locale = useLocale();
const date = new Date();

const formattedDate = new Intl.DateTimeFormat(locale, {
  year: 'numeric',
  month: 'long',
  day: 'numeric',
}).format(date);
```

**Currency:**

```typescript
const price = 150;
const currency = 'GEL';

const formattedPrice = new Intl.NumberFormat(locale, {
  style: 'currency',
  currency: currency,
}).format(price);
```

## Testing i18n

### Unit Tests

```typescript
import { NextIntlClientProvider } from 'next-intl';

test('renders translated text', () => {
  const messages = {
    home: {
      title: 'Test Title'
    }
  };

  render(
    <NextIntlClientProvider locale="en" messages={messages}>
      <HomePage />
    </NextIntlClientProvider>
  );

  expect(screen.getByText('Test Title')).toBeInTheDocument();
});
```

### Manual Testing Checklist

- [ ] All pages render in each language
- [ ] Language switcher works
- [ ] URLs contain correct locale
- [ ] Fallback to default language if translation missing
- [ ] Forms submit with correct locale
- [ ] Email notifications in correct language
- [ ] Date/number formatting correct per locale

## Common Issues

### Missing Translations

**Problem:** Key not found error

**Solution:**
```typescript
// Add fallback
{t('key', { defaultValue: 'Fallback text' })}
```

### Mixed Languages

**Problem:** Some text in wrong language

**Solution:**
- Check translation file has all keys
- Verify locale is passed correctly
- Check database has translation for that locale

### SEO in Multiple Languages

**Add hreflang tags:**

```typescript
// app/[locale]/layout.tsx
export async function generateMetadata({ params: { locale } }) {
  return {
    alternates: {
      canonical: `/${locale}`,
      languages: {
        'fr': '/fr',
        'en': '/en',
        'ka': '/ka',
      },
    },
  };
}
```

## Best Practices

1. **Never hardcode text** in components
2. **Always use translation keys**
3. **Group related translations** in the same namespace
4. **Keep keys semantic**, not literal translations
5. **Use pluralization** when needed
6. **Provide context** in key names
7. **Test all languages** before deploying
8. **Document new keys** for translators

## Resources

- [next-intl Documentation](https://next-intl-docs.vercel.app/)
- [ICU Message Format](https://unicode-org.github.io/icu/userguide/format_parse/messages/)
- [CLDR - Unicode Locale Data](http://cldr.unicode.org/)
- [W3C i18n Guidelines](https://www.w3.org/International/)
